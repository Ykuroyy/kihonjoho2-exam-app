import { Question } from '@/types/exam';

export const r7BQuestions: Question[] = [
  {
    id: 'R7B001',
    category: 'B',
    text: `次のプログラム中の【 a 】と【 b 】に入れる正しい答えの組合せを、解答群の中から選べ。

関数 function1 が受け取る引数と、関数 function2 が受け取る引数とが同じとき、二つの関数は同じ値を返す。ここで、引数 n と引数 m は正の整数であり、引数 m は引数 n よりも 10 以上大きい数とする。

〔プログラム〕
○整数型: function1(整数型: n, 整数型: m)
  整数型: count ← 0
  整数型: i
  for (iをnからmまで1ずつ増やす)
    if ((i mod 4)が0と等しい)
      count ← count ＋ 1
    endif
  endfor
  return count

○整数型: function2(整数型: n, 整数型: m)
  整数型: count ← 0
  整数型: tempN ← n
  整数型: i, j
  for ( 【 a 】 )
    if ((tempN mod 4)が0と等しい)
      繰返し処理を終了する
    endif
    tempN ← tempN ＋ 1
  endfor
  for ( 【 b 】 )
    count ← count ＋ 1
  endfor
  return count`,
    options: [
      'ア: a=iを1から2まで1ずつ増やす, b=jをnから始めてmを超えない範囲でtempNずつ増やす',
      'イ: a=iを1から2まで1ずつ増やす, b=jをtempNからmまで1ずつ増やす',
      'ウ: a=iを1から2まで1ずつ増やす, b=jをtempNから始めてmを超えない範囲で4ずつ増やす',
      'エ: a=iを1から3まで1ずつ増やす, b=jをnから始めてmを超えない範囲でtempNずつ増やす',
      'オ: a=iを1から3まで1ずつ増やす, b=jをtempNからmまで1ずつ増やす',
      'カ: a=iを1から3まで1ずつ増やす, b=jをtempNから始めてmを超えない範囲で4ずつ増やす'
    ],
    correctAnswer: 5,
    explanation: 'function1はnからmまでの4の倍数の個数をカウントします。function2も同じ結果を返すため、最初のループでtempNを4の倍数まで調整し、2番目のループで4ずつ増やしながらカウントします。',
    topic: 'アルゴリズム',
    image: '/images/r7b001-pdf.png'
  },
  {
    id: 'R7B002',
    category: 'B',
    text: `次のプログラム中の【　】に入れる正しい答えを、解答群の中から選べ。

関数 change は、10 より大きい整数を引数 n で受け取り、1 円玉、5 円玉、10 円玉を使ってちょうど n 円にする組合せの総数を返す。

例えば、12 円にする組合せは、次のように数えられる。10 円玉を使わない場合には、1 円玉と 5 円玉だけでちょうど 12 円にすることになる。その組合せは、使える 5 円玉の枚数が 0 以上 (12 ÷ 5 の商) 以下なので、(12 ÷ 5 の商) ＋ 1 ＝ 3 通りある。同様に、10 円玉を 1 枚使う場合には、1 円玉と 5 円玉だけでちょうど 2 円にすることになり、その組合せは (2 ÷ 5 の商) ＋ 1 ＝ 1 通りある。10 円玉を 2 枚以上使う組合せはない。よって、1 円玉、5 円玉、10 円玉を使ってちょうど 12 円にする組合せは、3 ＋ 1 ＝ 4 通りである。

〔プログラム〕
○整数型: change(整数型: n)
  整数型: count ← 0
  整数型: rest ← n
  while ( 【　】 )
    count ← count ＋ (rest ÷ 5 の商) ＋ 1
    rest ← rest － 10
  endwhile
  return count`,
    options: [
      'rest ≧ 0',
      'rest ≧ 5',
      'rest ≧ 10',
      'rest ＞ 0',
      'rest ＞ 5',
      'rest ＞ 10'
    ],
    correctAnswer: 0,
    explanation: '10円玉を使う枚数を増やしながら、残りの金額で5円玉と1円玉の組み合わせを数えます。rest ≧ 0の条件により、10円玉で全額を超えない範囲で処理を続けます。',
    topic: 'アルゴリズム',
    image: '/images/r7b002-pdf.png'
  },
  {
    id: 'R7B003',
    category: 'B',
    text: `次のプログラム中の【 a 】と【 b 】に入れる正しい答えの組合せを、解答群の中から選べ。ここで、配列の要素番号は 1 から始まる。

関数 push は、引数で与えられた整数をスタックに格納する。格納できた場合は true を返し、格納できなかった場合は false を返す。
関数 pop は、スタックから値を取り出して返す。スタックが空のときは未定義の値を返す。

スタックを、要素数が 4 である大域の整数型の配列 stack、及び次に値を格納する位置を示す大域の変数 stackPos で表現する。スタックの初期状態は、stack = {4, 3, 未定義の値, 未定義の値}、stackPos = 3 である。

〔プログラム〕
大域: 整数型: stackPos ← 3
大域: 整数型の配列: stack ← {4, 3, 未定義の値, 未定義の値}

○論理型: push(整数型: inputData)
  if (stackPos ≦ stackの要素数)
    stack[【 a 】] ← inputData
    stackPos ← stackPos ＋ 1
    return true
  else
    return false
  endif

○整数型: pop()
  整数型: popData ← 未定義の値
  if (stackPos ＞ 1)
    stackPos ← 【 b 】
    popData ← stack[stackPos]
    stack[stackPos] ← 未定義の値
  endif
  return popData`,
    options: [
      'ア: a=stackPos, b=stackPos ＋ 1',
      'イ: a=stackPos, b=stackPos － 1',
      'ウ: a=stackPos － 1, b=stackPos ＋ 1',
      'エ: a=stackPos － 1, b=stackPos － 1'
    ],
    correctAnswer: 1,
    explanation: 'スタックの実装で、stackPosは次に値を格納する位置を示します。pushではstackPosの位置に格納してからインクリメント、popではデクリメントしてからその位置の値を取り出します。',
    topic: 'データ構造',
    images: ['/images/r7b003-1pdf.png', '/images/r7b003-2pdf.png']
  },
  {
    id: 'R7B004',
    category: 'B',
    text: `次の記述中の【　】に入れる正しい答えを、解答群の中から選べ。ここで、配列の要素番号は 1 から始まる。

関数 search は、二つの文字型の配列を、それぞれ引数 data 及び key で受け取り、data から、key の要素の並びと同じ並びを全て探し、その先頭の要素番号を全て格納した配列を返す。見つからなければ、要素数 0 の配列を返す。

関数 search を search({"a", "b", "a", "b", "c", "a", "b", "c"}, {"a", "b", "c"}) として呼び出すと、/*** β ***/の行の条件式が真となる回数は【　】回である。

〔プログラム〕
/* keyは、要素数1以上の配列である */
○整数型の配列: search(文字型の配列: data, 文字型の配列: key)
  整数型: i, j, lenData, lenKey
  整数型の配列: result ← {} // 要素数0の配列
  lenData ← dataの要素数
  lenKey ← keyの要素数
  
  /* (lenData － lenKey ＋ 1) が0以下のときは繰返し処理を実行しない */
  for (i を 1 から (lenData － lenKey ＋ 1) まで 1 ずつ増やす)
    for (j を 1 から lenKey まで 1 ずつ増やす) // α
      if (data[i ＋ j － 1] が key[j] と等しい) /*** β ***/
        if (j が lenKey と等しい)
          resultの末尾 に iの値 を追加する
        endif
      else
        αの行から始まる繰返し処理を終了する
      endif
    endfor
  endfor
  return result`,
    options: [
      '1',
      '2',
      '3',
      '4',
      '5',
      '6',
      '7',
      '8',
      '9',
      '10'
    ],
    correctAnswer: 7,
    explanation: 'data配列で"abc"のパターンを探索します。i=3とi=6で完全一致し、それぞれ3回ずつ条件が真になります。また、i=1で1回真になった後に不一致で終了。合計8回です。',
    topic: 'アルゴリズム',
    image: '/images/r7b004-pdf.png'
  },
  {
    id: 'R7B005',
    category: 'B',
    text: `次の記述中の【 a 】と【 b 】に入れる正しい答えの組合せを、解答群の中から選べ。ここで、配列の要素番号は 1 から始まる。

予防接種の病気 X に対する予防効果を調査するために集めたデータの集計結果を基に、病気 X にかかるかどうかが、予防接種の有無に影響されないと仮定した場合の人数を計算する。この人数を理論度数という。

関数 f は、引数 data で受け取った集計結果を基に計算した理論度数を返す。引数と戻り値は二次元配列で、その行が表の行、その列が表の列に対応する。

表1の集計結果の例：
- 予防接種を受けた・病気Xにかからなかった: 82人
- 予防接種を受けた・病気Xにかかった: 6人  
- 予防接種を受けていない・病気Xにかからなかった: 58人
- 予防接種を受けていない・病気Xにかかった: 8人

表2を基に計算した理論度数で、予防接種を受けた・病気Xにかからなかった場合は【 a 】人、予防接種を受けていない・病気Xにかかった場合は【 b 】人である。

〔プログラム〕
○実数型の二次元配列: f(実数型の二次元配列: data)
  実数型: t ← dataの要素の和
  整数型: row ← dataの行数
  整数型: col ← dataの列数
  実数型の二次元配列: result ← {row行col列の 未定義の値}
  整数型: r, c
  for (r を 1 から row まで 1 ずつ増やす)
    for (c を 1 から col まで 1 ずつ増やす)
      result[r, c] ← (dataの行番号rの要素の和) × (dataの列番号cの要素の和) ÷ t
    endfor
  endfor
  return result`,
    options: [
      'ア: a=44, b=33',
      'イ: a=58, b=8',
      'ウ: a=70, b=7',
      'エ: a=75, b=2',
      'オ: a=80, b=6',
      'カ: a=80, b=8',
      'キ: a=82, b=6'
    ],
    correctAnswer: 4,
    explanation: '理論度数は(行の和×列の和)÷全体の和で計算します。予防接種を受けた・かからなかった=(88×140)÷154=80、受けていない・かかった=(66×14)÷154=6',
    topic: '統計',
    images: ['/images/r7b005-1-pdf.png', '/images/r7b005-2-pdf.png']
  },
  {
    id: 'R7B006',
    category: 'B',
    text: `A社は従業員200名の電子機器メーカーである。東京に本社があり、新潟に工場がある。

A社では、ファイルサーバを次のように運用している。
・土曜日の午前2時からフルバックアップを取得
・翌週の火曜日と木曜日の午前2時から増分バックアップを取得
・フルバックアップからのリストアには平均して4時間、1回の増分バックアップからは平均して0.25時間
・目標復旧時点（RPO）は72時間、目標復旧時間(RTO)は120時間

表2 内部監査室へのBさんの回答（抜粋）
1. 例えば、金曜日の正午に障害が発生した場合、少なくとも【 a1 】の時点のデータは復元しなければならない。
2. 例えば、木曜日の正午に障害が発生し、ファイルサーバの全データが消失したとすると、バックアップからのリストアには【 a2 】時間掛かると予想される。
3. ICT継続の計画書は、【 a3 】が承認している。

【 a1 】～【 a3 】に入れる字句の適切な組合せを選べ。`,
    options: [
      'ア: a1=月曜日の正午, a2=4.25, a3=CISO',
      'イ: a1=月曜日の正午, a2=4.25, a3=情報システム部の担当者',
      'ウ: a1=月曜日の正午, a2=4.25, a3=内部監査室長',
      'エ: a1=月曜日の正午, a2=4.50, a3=CISO',
      'オ: a1=月曜日の正午, a2=4.50, a3=情報システム部の担当者',
      'カ: a1=火曜日の正午, a2=4.25, a3=情報システム部の担当者',
      'キ: a1=火曜日の正午, a2=4.25, a3=内部監査室長',
      'ク: a1=火曜日の正午, a2=4.50, a3=CISO',
      'ケ: a1=火曜日の正午, a2=4.50, a3=情報システム部の担当者',
      'コ: a1=火曜日の正午, a2=4.50, a3=内部監査室長'
    ],
    correctAnswer: 7,
    explanation: 'RPO72時間から金曜正午の72時間前は火曜正午。木曜正午の障害では土曜フルバックアップ(4時間)+火曜増分(0.25時間)+木曜増分(0.25時間)=4.50時間。ICT継続計画は最高情報セキュリティ責任者(CISO)が承認。',
    topic: 'セキュリティ',
    images: ['/images/r7b006-1pdf.png', '/images/r7b006-2pdf.png']
  }
];